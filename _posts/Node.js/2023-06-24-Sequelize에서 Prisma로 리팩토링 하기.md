---
layout: post
title: Sequelize에서 Prisma로 리팩토링 하기
description: >
  기존에 했던 프로젝트에서 Sequelize를 걷어내고 Prisma로 리팩토링하는 과정을 정리했다.  
tags: 
---
# Sequelize에서 Prisma로 리팩토링 하기

- [Sequelize에서 Prisma로 리팩토링 하기](#sequelize에서-prisma로-리팩토링-하기)
  - [Prisma란?](#prisma란)
  - [Prisma를 사용하게 된 이유](#prisma를-사용하게-된-이유)
  - [리팩토링 하면서 만났던 이슈](#리팩토링-하면서-만났던-이슈)
  - [추가: PlanetScale 연결하기](#추가-planetscale-연결하기)
  - [이후 계획](#이후-계획)
  - [마치며](#마치며)

## Prisma란?

Prisma는 차세대 ORM으로, 데이터베이스를 쉽게 다룰 수 있게 해준다.  
기존의 ORM과는 달리, 데이터베이스를 직접 다루는 것이 아니라 Prisma가 데이터베이스를 다루는 방식으로 코드를 작성하면 Prisma가 데이터베이스를 다루는 코드를 생성해준다.  

## Prisma를 사용하게 된 이유

1. PlanetScale
  PlanetScale 이라는 DB를 사용하려고 했으나, 해당 서비스는 Vitness를 기반이었다.  
  즉, *관계형 DB를 사용할 수 없었다.*  
  이게 무슨 소리야. 데이터 사이에 관계를 못 만들면 그게 무슨 소용이야...  
  그래서 조금 더 찾아보니, Prisma를 사용하면 관계형 DB를 사용하지 않아도 관계형 DB처럼 사용할 수 있다고 한다.  
  사실 이게 Prisma를 사용하게 된 가장 큰 이유이다.  
2. Prisma의 장점
  일단 TS를 지원한다.  
  Sequelize는 TS를 지원하지 않아서, 타입을 매번 새로 만들어야 했다.  
  Prisma는 스키마를 기반으로 타입까지 직접 작성해주기 때문에, 타입을 따로 만들 필요가 없어서 너무 편했다!  
  특히 Sequelize는 TS를 지원하지 않아 DB 모델 생성 코드를 TS로 바꿔줘야 했다.  
  하지만, Prisma는 스키마를 작성하면 `PrismaClient` 인스턴스를 생성해서 사용하기만 하면 됐다.  
  또, Prisma는 데이터를 불러올 때, 관계된 데이터를 한 번에 불러올 수 있었다.  

## 리팩토링 하면서 만났던 이슈

1. 메소드의 차이
  대부분의 경우 비슷한 이름이었지만, `findOne`은 `findUnique`(유일한 값으로 조회할 때), `findFirst`(유일하지 않은 값으로 조회할 때), `findAll`은 `findMany`로 바뀌었다.  
  또 인자로 넣는 값도 조금씩 달랐다.  
  예를 들어, `sequelize`의 `findOne`은 속성 별로 값이 지정된 객체를 넘겨주면 됐다.  
  하지만, `prisma`의 `findUnique`는 바로 값을 넘겨주면 안되고, `{ where: { 속성: 값 } }` 형식으로 넘겨줘야 했다.  
  이런 차이점 때문에, 기존에 작성했던 코드를 그대로 사용할 수 없었기에 조금씩 변경해줘야 했다.  
2. 반환값의 차이
  `sequelize`의 경우, 조회한 값은 `dataValues`에 담겨있었다.  
  하지만, `prisma`의 경우, 조회한 값을 바로 사용할 수 있었다.  
  변경하는게 귀찮긴 했지만 편한 점이라고 느꼈다.  
3. DB 객체
  `sequelize`의 경우, 모델을 직접 작성해야 했다.  
  게다가 TS를 지원하지 않아, DB 객체 생성 코드를 TS로 바꿔줘야 했다.  
  하지만, `prisma`의 경우, 스키마를 작성하면 자동으로 모델까지 생성되었다.  
  이를 `PrismaClient` 인스턴스를 생성하면 바로 사용할 수 있었다.  
  게다가 마이그레이션도 할 필요 없이, 스키마 수정 후 `prisma push` 명령어를 통해 DB에 반영할 수 있었다.  
  모델의 타입들도 자동으로 생성되고 변경돼서 진짜 너무너무너무 편했다.  

변경할 점이 조금 있긴 했지만, 대부분의 코드는 그대로 사용할 수 있었다.  
게다가 오히려 편하게 된 부분이 훨씬 더 많아서 너무 좋았다.  
타입 자동 작성 진짜 짱 편함... <small><small><small>대박샌즈</small></small></small>

## 추가: PlanetScale 연결하기

1. PlanetScale에 계정 및 DB 생성
  PlanetScale에 계정을 생성한다.  
  이때, GitHub 계정으로 로그인하는 것을 추천한다.  
  GitHub 계정으로 로그인하면, GitHub에 저장된 SSH 키를 사용할 수 있기 때문이다. (코파일럿이 알려줬다. 팩트체크 필요함.)
  계정을 생성한 뒤, DB와 DB에 연결된 계정을 생성한다.  
2. 스키마 수정
  스키마의 `datasource db` 부분에 `relation="prisma"`를 추가한다.
3. DB URL 환경변수로 설정
  만약 DB 계정 생성까지 완료 했다면, DB URL을 'mysql://<DB 계정 이름>:<DB 계정 비밀번호>@aws.connect.psdb.cloud/<DB 이름>?ssl={"rejectUnauthorized":true}' 로 설정하라고 안내한다.  
  이를 'DATABASE_URL' 환경 변수로 넣어주면 된다.  (Prisma 스키마에서 DB URL로 사용할 변수를 설정하거나 URL을 직접 하드 코딩할 수 있다.)
  하지만 바로 연결하려고 하면 연결이 되지 않을 것이다.  
  PlanetScale에서는 기본적으로 SSL 연결만을 허용하기 때문이다.
  맥 사용자라면 '&sslcert=/etc/ssl/cert.pem' 를 붙여 주면 된다.  
  혹은 본인만의 인증서를 사용하고 싶다면, 해당 인증서의 경로를 넣어주면 된다.  
4. `prisma db push`
  이제 `prisma db push` 명령어를 통해 DB에 연결할 수 있다.
  스키마를 변경해도 마이그레이션 할 필요 없이, 해당 명령어를 통해 DB에 반영할 수 있다.

## 이후 계획

BE와 FE를 분리했기 때문에, FE에서 BE로 요청을 보내는 부분을 수정해야 한다.  
또한 일부 모델도 좀더 디벨롭할 생각이다.  

## 마치며

[**이번 변경사항이 담긴 PR**](https://github.com/2chanhaeng/today-sky-be/pull/1)
사실 이번 리팩토링은 굉장히 간단했다.  
다만 리팩토링 하면서 추가로 변경한 점들이 조금씩 있다.  
예를 들어 에러 타입을 새로 생성하고 일괄적으로 처리하게 만들었다.  
또한 API가 반환하는 값도 조금씩 변화를 줬다.  
이를 다시 테스트에 반영하고 하는 시간이 조금 걸렸다.  
하지만 확실히 테스트를 해야 어디서 문제가 나는지 그때그때 바로 알 수 있었고, 이를 해결하면서 코드도 더 깔끔해졌다.  
그리고 내 생각에, 만약 테스트 없이 리팩토링만 진행했다면, 후에 문제가 생겼을 때 어디서 문제가 생겼는지 찾기가 훨씬 힘들었을 것이다.  
TDD 최고!  
