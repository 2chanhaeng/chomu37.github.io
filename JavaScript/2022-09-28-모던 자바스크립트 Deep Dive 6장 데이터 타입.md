---
layout: post
category: JavaScript
title: 모던 자바스크립트 Deep Dive 6장 데이터 타입
description: >
  JS의 데이터 타입은 숫자, 문자열, 불리언, undefined, null, 심벌을 포함한 원시 타입과 객체 타입으로 나뉜다.
tags: [JavaScript]
---
# 데이터 타입

- 값의 종류
- 자바스크립트의 모든 값은 타입을 가짐
- 자바스크립트의 타입은 8가지
  - 원시 타입
    - 숫자 타입: 실수 혹은 $2^{53} - 1$ 이하의 정수 값
    - BigInt 타입: $2^{53}$ 이상의 정수값
    - 문자열 타입
    - 불리언 타입
    - `undefined` 타입: 선언된 변수에 암묵적으로 할당되는 값
    - `null` 타입: 값이 없음을 명시하는 값
    - 심벌 타입: 33장
  - 객체 타입: 11장

## 원시 타입

### 숫자 타입

- 정수와 실수의 차이 없이 오직 한가지 타입으로만 구분
- 64비트 부동소수점 형식
- 진법 별 표기법

  |이진법|`0b000`|
  |팔진법|`0o000`|
  |십육진법|`0x000`|

   - 진법이 달라도 값이 같다면 모두 같은 값
- 특별한 숫자 타입 값

  |`Infinity`|양의 무한대|
  |`-Infinity`|음의 무한대|
  |`NaN`|Not a Number, 산술 연산 불가능|

### 문자열 타입

- 16비트 유니코드 문자(UFT-16)의 집합
- 작은따옴표', 큰따옴표", 백틱`으로 둘러싸 표현
- 템플릿 리터럴
  - 백틱`으로 둘러싼 텍스트
  - 멀티라인 문자열: 여러 줄의 문자열도 하나의 백틱 쌍으로 표현 가능
  - 표현식 삽입: `${`와 `}` 사이에 표현식을 넣으면 그 값이 문자열로 변환되어 삽입
  - 태그드 템플릿
    - 템플릿 리터럴 표현식을 분해하는 방법
      ```javascript
      // https://bloodstrawberry.tistory.com/443
      console.log("taggedTemplateLiterals");
      function taggedTemplateLiterals(str, ...rest) {
        console.log(str);
        console.log(rest);
        return "return from taggedTemplateLiterals"
      }

      console.log("values for param");
      let value1 = 10;
      let value2 = "ten";
      let value3 = false;

      console.log("result");
      const result = taggedTemplateLiterals`ABC${value1}EFG${value2}HIJ${value3}`;

      console.log("console.log({ result })");
      console.log({ result });
      ```
      출력:
      > ```javascript
      > taggedTemplateLiterals
      > values for param
      > result
      > [ "ABC", "EFG", "HIJ", "" ]
      > [ 10, "ten", false ]
      > console.log({ result })
      > { result: "return from taggedTemplateLiterals" }
      > ```
- 이스케이프 시퀀스
  - 백슬래시\\로 특별한 문자를 표현하는 방법

    |이스케이프 시퀀스|의미|
    |---|---|
    |`\0`|Null|
    |`\b`|Backspace|
    |`\f`|Form Feed, 프린터 출력 시 다음 페이지로 넘어감|
    |`\n`|Line Feed[^CRLF], 줄바꿈, 다음 행으로 이동|
    |`\r`|Carriage Return[^CRLF], 커서를 처음으로 이동|
    |`\t`|수평 탭|
    |`\v`|수직 탭|
    |`\uXXXX`|유니코드(십육진법)|
    |`\'`|작은따옴표|
    |`\"`|큰따옴표|
    |<code>\\\`</code>|백틱|
    |`\`|백슬래시|

[^CRLF]:
    > LF(Line Feed)와 CR(Carriage Return)
    > ---
    > 타자기에서 LF는 종이를 한 줄 위로 올리고, CR은 커서를 맨 앞줄로 이동할 때 쓰였다. 여기서 비롯된 초창기 컴퓨터는 프린트를 할 때 개행을 위해 CRLF(\r\n)를 사용하였다. 현대 컴퓨터 운영체제 중 윈도우만이 CRLF로 개행을 이용하고 맥(OSX 이후, 9까지는 CR을 이용)과 유닉스는 LF로 개행을 한다. JS는 CR, LF 둘다 개행으로 취급한다.

### 불리언 타입

논리적 참`true`, 거짓`false`을 나타내는 값

### `undefined`

- 변수 선언[^선언과_정의]에 의해 확보된 메모리 공간이 처음 할당될 때 빈 상태[^빈_상태]일 경우 JS 엔진이 암묵적으로 할당하는 값
- 엔진 내에서 사용하는 값이므로 사용자는 `undefined` 대신 `null`을 이용하는 것이 권장됨
  
[^선언과_정의]: 다른 언어에서는 선언declaration과 정의definition가 명확히 구분된다. C의 경우 "실제로 메모리 주소를 할당"하는 지를 기준으로 선언은 식별자의 존재만 알리는 것, 정의는 식별자와 메모리 주소가 연결되는 것으로 구분한다. 하지만 JS의 경우 변수 선언 시 암믁적으로 `undefined`가 할당되므로 선언과 정의의 경계가 모호하다. 이 책은 ECMAScript를 따라 변수는 선언, 함수는 정의로 표현을 한다.

[^빈_상태]: 대부분 실제로 비어있기보단 쓰레기 값이 들어있다.

### `null`

- 변수에 값이 없다는 것을 의도적으로 명시(의도적 부재 intentional absence)할 때 사용
- 이전에 참조하던 값을 더 이상 참조않겠다는 의미로 변수에 `null`을 할당
- 할당되어 있던 값에 대한 참조를 명시적 제거
- 일부 함수는 유효한 값을 반환할 수 없는 경우 명시적으로 `null`을 반환(ex: 브라우저의 `document.querySelector`)

### 심벌 타입

- 변경 불가하고 다른 값과 중복되지 않는 유일무이한 값
- 이름이 충돌할 위헙 없는 객체의 유일한 프로퍼티 키를 만들 때 사용
- 다른 원시 값은 리터럴을 통해 생성하나 심벌은 `Symbol` 함수를 호출해 생성
- ES6에서 추가됨
- 자세한 내용은 33 장에서!

### 객체 타입

11장

# 데이터 타입의 필요성

1. 할당 시 메모리 공간 확보: 
    값의 종류에 따라 정해진 크기의 메모리 공간을 확보
2. 참조 시 메모리 셀 공간 결정: 
    메모리에서 한 번에 읽어야하는 메모리 셀 블럭의 크기 결정
3. 값 해석: 
    타입에 따라 비트 해석

# 동적 타이핑

## 동적 타입 언어과 정적 타입 언어

- 정적 타입
  - 명시적 타입 선언: 변수 선언 시 변수에 할당할 수 있는 타입 선언 필수
  - 컴파일 시 타입 체크
- 동적 타입
  - 타입 추론: 선언이 아닌 할당에 의해 타입 결정
  - 어떤 변수에든 어떤 타입의 값도 자유롭게 할당 가능
  - 재할당에 의해 변수 타입 언제든 동적으로 변화 가능
## 동적 타입 언어와 변수
- 동적 타이핑의 장점
  - 타입 선언이 자유로움
  - 편리함
- 동적 타이핑의 단점
  - 복잡성 높아 추적이 어려울 경우 타입 확신 현실적 불가
  - 암묵적으로 타입이 변환되어 오류 발생 가능

⇒ 유연성은 높으나 신뢰성 낮음

이를 대비하기 위해
- 변수를 최소한으로 유지
- 변수 유효 범위(스코프) 좁게하여 부작용 억제(13장)
- 전역 변수 자제(14장)
- 변수보다는 상수(const) 위주 사용(15장)
- 목적, 의미 파악 가능한 명확한 네이밍
- 유효 범위 넓을수록 특히 더 명확한 이름

<b style="font-size:10vw" >가독성이 좋은 코드가 좋은 코드!</b>
> 컴퓨터가 이해하는 코드는 어떤 바보도 쓸 수 있다. 하지만 훌륭한 프로그래머는 사람이 이해할 수 있는 코드를 쓴다.\
>\- 마틴 파울러 Martin Fowler
